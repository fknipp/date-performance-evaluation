/**
 *
 * @short Various functions for date time calculations and date string parsing.
 * 
 * $Id: mdate.cpp,v 1.2 2006-03-31 08:33:49 knipp Exp $
 *
 * @author  $Author: knipp $
 * @version $Revision: 1.2 $
 *
 */

#include "decl.h"
#include "mdate.h"
#include<stdio.h>
#include<string.h>
#include<math.h>

/**
 * Converts the broken-down time structure to calendar time representation
 * considering the given offset.
 *
 * @param tm Time structure containing tm_gmtoff (BSD extension).
 * @return The calendar time.
 *
 * The time structure is neither normalized nor tested for validity.
 *
 * The algorithm is based solely on integer operations and does not use any
 * control statements like 'for' or 'if'. To consider the leap day, the number
 * of days is calculated by moving the start of a year to the first of March
 * (see the variable rmon). January and February are assigned to the year
 * before (see ryear).
 */
time_t mktime_offset(const struct tm *tm) 
{

  // calculate shifted month and year
  int rmon = (tm->tm_mon + 10) % 12;
  int ryear = tm->tm_year + (tm->tm_mon - 11) / 10;

  // set day of month
  time_t ret = tm->tm_mday;

  // add the number of days of the months before
  ret += (3 * rmon + 2) / 5 + rmon * 30;  

  // add leap days
  ret += ryear / 4;
  ret -= ryear / 100;
  ret += (ryear + 300) / 400;

  // add years
  ret += ryear * 365; 

  // offset for 1. 1. 1970 (the epoch)
  ret -= 25509;

  // convert days to seconds
  ret *= 24 * 3600;

  // add time
  ret += ((tm->tm_hour * 60) + tm->tm_min) * 60 + tm->tm_sec;

  // subtract time zone
  ret -= tm->tm_gmtoff;

  return ret;

}

/** The names of the months according used for RFC822-compliant date strings */
const char * RFC822MonthNames[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
				     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

/** 
 * Parses an RFC822 compliant date and stores the values in the broken-down
 * time structure.
 *
 * @param str The string to parse.
 * @param tm The structure for broken-down representation.
 * @return The number of unparsed elements (should be lower than four).
 *
 * The components tm_wday, tm_yday, tm_isdst are not set in the time structure.
 * Time zone information is only parsed in the numeric form. The time structure
 * may not be filled with 0 before.
 *
 * Example for such a date: Thu, 30 Mar 2006 16:43:02 +0200
 */
int parseRFC822Date(const char* str, struct tm *tm)
{

  char monString[4];
  char zsign;
  int zhour = 0;
  int zmin = 0;

  tm->tm_sec = 0;

  // Skip day in front of string
  if(*str > '9') str += 5;

  int rc = sscanf(str, "%d %3s %d %2d:%2d:%2d %c%2d%2d", 
		  &tm->tm_mday, monString, &tm->tm_year, 
		  &tm->tm_hour, &tm->tm_min, &tm->tm_sec,
		  &zsign, &zhour, &zmin);

  // At least five elements must be found for proper function
  if(rc < 6) return 9 - rc;

  // Find month
  tm->tm_mon = -1;

  for(int i = 0; i < 12; i++) 
    if(!strncmp(monString, RFC822MonthNames[i], 3)) {
      tm->tm_mon = i;
      break;
    }

  // Shift year
  tm->tm_year -= 1900;

  // Save timezone information
  tm->tm_gmtoff = ((zsign == '-') ? -1 : 1) * (zhour * 60 + zmin) * 60;

  return 9 - rc;

}

/** 
 * Parses an XML Schema DateTime string and stores the values in the 
 * broken-down time structure.
 *
 * @param str The string to parse.
 * @param tm The structure for broken-down representation.
 * @return The number of unparsed elements, 3, if the string contains no 
 *         time zone information, or 0 in case of success.
 *
 * The components tm_wday, tm_yday, tm_isdst are not set in the time structure.
 * The time structure may not be filled with 0 before. The algorithm is not
 * very strict regarding the length of the values.
 */
int parseXMLDateTime(const char* str, struct tm *tm)
{

  char zsign;
  int zhour, zmin;
  float sec;

  int rc = sscanf(str, "%d-%d-%dT%d:%d:%f%c%d:%d", 
		  &tm->tm_year, &tm->tm_mon, &tm->tm_mday, 
		  &tm->tm_hour, &tm->tm_min, &sec,
		  &zsign, &zhour, &zmin);

  // At least six elements must be found for standard compliance
  if(rc < 6) return 9 - rc;

  // Save seconds
  tm->tm_sec = lrint(floor(sec));

  // Shift month
  tm->tm_mon--;

  // Shift year
  tm->tm_year -= 1900;

  if(rc == 6) return 3;

  // Save timezone information
  if(zsign == 'Z')
    tm->tm_gmtoff = 0;
  else
    tm->tm_gmtoff = ((zsign == '-') ? -1 : 1) * (zhour * 60 + zmin) * 60;

  return 0;
}

#ifdef MAIN

/**
 * Test function.
 *
 * Can be generated by compilation with
 *
 * g++ -o mdate -I../../include -DMAIN mdate.cpp
 */
int main(int argc, char** argv) {

  if(argc > 2) {

    struct tm tm;
    tm.tm_isdst = -1;
    int rc;
    if(!strncmp(argv[1], "rfc", 3))
      rc = parseRFC822Date(argv[2], &tm);
    else
      rc = parseXMLDateTime(argv[2], &tm);
    printf("Parsing: %s\n", argv[2]);
    printf("rc: %i\n", rc);
    printf("tm->tm_hour: %i\n", tm.tm_hour);
    printf("tm->tm_gmtoff: %i\n", tm.tm_gmtoff);
    time_t ts = mktime_offset(&tm);
    printf("ts: %i\nctime: %sasctime: %s", ts, ctime(&ts), asctime(&tm));
    printf("tm->tm_hour: %i\n", tm.tm_hour);
    time_t ts2 = mktime(&tm);
    printf("ts: %i\nctime: %sasctime: %s", ts, ctime(&ts2), asctime(&tm));
    printf("tm->tm_hour: %i\n", tm.tm_hour);

  }

  return 0;

}

#endif
